- Canvas 是屬於瀏覽器端標籤，屬於前端程式碼，我使用react在konva套件繪製好了的圖形後的一些狀態，比如元件的 x,y狀態，我想把這些狀態儲存到我的資料庫，資料庫已經有寫 rest api，但canvas是在瀏覽器端做的，next.js裡有什麼做法可以在前端儲存到資料庫而不暴露 api key在前端?

可以透過 Next.js 的 **Route Handler**（`app/api/.../route.ts`）或 **Server Actions** 當作後端代理，前端只呼叫同源 API，不暴露密鑰。做法：

1. 將 API key 放 [.env](vscode-file://vscode-app/c:/Program%20Files/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)，只在伺服器端讀取（`process.env.MY_API_KEY`）。
2. 建立 `app/api/canvas/route.ts`，在伺服器端呼叫你的 REST API。
3. 前端（canvas 客戶端）用 `fetch("/api/canvas", { method: "POST", body: JSON.stringify(data) })` 傳狀態即可。

範例 Route Handler（Next.js App Router）：
```TypeScript
import { NextResponse } from "next/server";

const API_KEY = process.env.MY_API_KEY;
const API_BASE = process.env.MY_API_BASE ?? "https://your-api.example.com";

export async function POST(req: Request) {
  if (!API_KEY) {
    return NextResponse.json({ error: "API key missing" }, { status: 500 });
  }

  const payload = await req.json();
  const res = await fetch(`${API_BASE}/canvas`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": API_KEY,
    },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    const text = await res.text();
    return NextResponse.json({ error: text }, { status: res.status });
  }

  const data = await res.json();
  return NextResponse.json(data);
}
```

前端呼叫（你的 Konva 客戶端元件內）：
```TypeScript
async function saveCanvasState(state: unknown) {
  const res = await fetch("/api/canvas", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(state),
  });
  if (!res.ok) throw new Error("Save failed");
  return res.json();
}
```
重點：API key 只放伺服器端（Route Handler/Server Action），前端永遠呼叫同源 `/api/*`。

- 那麼，這還有一層隱憂，這樣看起來是每個人都可以 fetch我server的canvas api，這有什麼方法防範?

可以在 Next.js 加「伺服器代理」後，再加上身份驗證與風險控管，避免任何人隨便呼叫：

1. **先驗證再轉發**：在 `/api/canvas`（Route Handler 或 Server Action）檢查登入狀態（Session/JWT/Cookie-based）。未登入直接 `401`，通過才代轉你的後端 REST API（帶上伺服器端的 API key）。
2. **CSRF 防護**：若用 Cookie 認證，啟用 SameSite=Lax/Strict，並在需要寫入的請求驗證 CSRF token。
3. **Rate limit / 風險控管**：在 Route Handler 加頻率限制（如按 IP/使用者），可用邏輯或第三方如 Upstash/KV 追蹤。
4. **輸入驗證**：用 Zod 驗證前端傳來的狀態資料，避免異常或注入。
5. **限制來源**：若只允許同源，前端請求走同域 `/api/canvas`，伺服器端可檢查 `Origin`/`Referer`（有限制但可增加摩擦）。
6. **權限分級**：如區分讀/寫/管理的權限，避免過度開放。

摘要：在 `/api/canvas` 做身份驗證 + CSRF + Rate limit + Zod 驗證，伺服器端再代呼你的 REST API，API key 永遠只在伺服器端。
